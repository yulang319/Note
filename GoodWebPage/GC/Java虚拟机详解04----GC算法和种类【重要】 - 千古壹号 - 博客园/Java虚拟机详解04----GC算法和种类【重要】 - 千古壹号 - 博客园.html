<!DOCTYPE html>
<!-- saved from url=(0046)https://www.cnblogs.com/smyhvae/p/4744233.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
    <title>Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园</title>
<meta property="og:description" content="【声明】 欢迎转载，但请保留文章原始出处→_→ 生命壹号：http://www.cnblogs.com/smyhvae/ 文章来源：http://www.cnblogs.com/smyhvae/p/4">
    <link type="text/css" rel="stylesheet" href="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/bundle-darkgreentrip.css">
<link type="text/css" rel="stylesheet" href="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/188761.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/bundle-darkgreentrip-mobile.css">
    <link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/qianguyihao/rss">
    <link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/qianguyihao/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/qianguyihao/wlwmanifest.xml">
    <script src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/amp4ads-host-v0.js.下载"></script><script src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/osd.js.下载"></script><script src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/pubads_impl_rendering_301.js.下载"></script><script async="" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/analytics.js.下载"></script><script type="text/javascript" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/encoder.js.下载"></script><script src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/jquery-2.2.0.min.js.下载"></script>
    <script>var currentBlogId=188761;var currentBlogApp='qianguyihao',cb_enable_mathjax=false;var isLogined=false;</script>
    <script src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/blog-common.js.下载" type="text/javascript"></script>
<link rel="preload" href="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/f(1).txt" as="script"><script type="text/javascript" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/f(1).txt"></script><script src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/pubads_impl_301.js.下载" async=""></script><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-31/html/container.html"></head>
<body>
<a name="top"></a>


<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/qianguyihao/"><img id="blogLogo" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/qianguyihao/">千古壹号</a></h1>
<h2>博客园分享技术，公众号分享代码之外的技能。微信公众号：千古壹号。</h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/qianguyihao/">首页</a></li>
<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
<li><a id="blog_nav_contact" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/%E5%8D%83%E5%8F%A4%E5%A3%B9%E5%8F%B7">联系</a></li>
<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/qianguyihao/rss">订阅</a>
<!--<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/qianguyihao/rss"><img src="//www.cnblogs.com/images/xml.gif" alt="订阅" /></a>--></li>
<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
</ul>
		<div class="blogStats">
			
			<div id="blog_stats">
<span id="stats_post_count">随笔 - 157&nbsp; </span>
<span id="stats_article_count">文章 - 0&nbsp; </span>
<span id="stats-comment_count">评论 - 605</span>
</div>
			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		
        <div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/qianguyihao/p/4744233.html">Java虚拟机详解04----GC算法和种类【重要】</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>&nbsp;</p>
<p><strong>【声明】</strong>&nbsp;</p>
<p>欢迎转载，但请保留文章原始出处→_→&nbsp;</p>
<p>生命壹号：<a href="http://www.cnblogs.com/smyhvae/" target="_blank">http://www.cnblogs.com/smyhvae/</a></p>
<p>文章来源：<a href="http://www.cnblogs.com/smyhvae/p/4744233.html">http://www.cnblogs.com/smyhvae/p/4744233.html</a><a href="http://www.cnblogs.com/smyhvae/p/4013535.html"><br></a></p>
<p><span style="line-height: 1.5;">&nbsp;</span></p>
<p>本文主要内容：</p>
<ul>
<li>GC的概念</li>
<li>GC算法</li>

















</ul>
<p>　　　&nbsp;引用计数法（无法解决循环引用的问题，不被java采纳）</p>
<p>&nbsp;&nbsp;&nbsp; 　　根搜索算法</p>
<p>&nbsp;&nbsp;&nbsp; 　　现代虚拟机中的垃圾搜集算法：</p>
<p>　　　　　　标记-清除</p>
<p>　　　　　　复制算法（新生代）</p>
<p>　　　　　　标记-压缩（老年代）</p>
<p>&nbsp;&nbsp;&nbsp; 　　分代收集</p>
<ul>
<li>Stop-The-World</li>

















</ul>
<p>&nbsp;</p>
<p><strong>一、GC的概念：</strong></p>
<ul>
<li>GC：Garbage Collection 垃圾收集</li>
<li>1960年 Lisp使用了GC</li>
<li>Java中，<span style="color: #0000ff;"><strong>GC的对象是Java堆和方法区</strong></span>（即永久区）</li>

















</ul>
<p>我们接下来对上面的三句话进行一一的解释：</p>
<p>（1）GC：Garbage Collection 垃圾收集。这里所谓的垃圾指的是<span style="color: #0000ff;"><strong>在系统运行过程当中所产生的一些无用的对象，这些对象占据着一定的内存空间，如果长期不被释放，可能导致OOM</strong></span>。</p>
<p>在C/C++里是由程序猿自己去申请、管理和释放内存空间，因此没有GC的概念。而在Java中，<span style="color: #0000ff;"><strong>后台专门有一个专门用于垃圾回收的线程</strong></span>来进行监控、扫描，自动将一些无用的内存进行释放，这就是垃圾收集的一个基本思想，<span style="color: #0000ff;">目的在于防止由程序猿引入的人为的内存泄露</span>。</p>
<p>（2）事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：</p>
<blockquote>
<p>哪些内存需要回收？</p>
<p>什么时候回收？</p>
<p>如何回收？</p>

















</blockquote>
<p>（3）内存区域中的<span style="color: #0000ff;"><strong>程序计数器、虚拟机栈、本地方法栈</strong></span>这3个区域随着线程而生，线程而灭；<span style="color: #0000ff;"><strong>栈中的栈帧</strong></span>随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作，每个栈帧中分配多少内存基本是<span style="color: #0000ff;"><strong>在类结构确定下来时就已知</strong>的。<strong>在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了</strong></span>。</p>
<p>而<span style="color: #0000ff;"><strong>Java堆和方法区</strong></span>则不同，一个接口中的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，<span style="color: #0000ff;"><strong>这部分内存的分配和回收都是动态的</strong></span>，GC关注的也是这部分内存，后面的文章中如果涉及到“内存”分配与回收也仅指着一部分内存。</p>
<p>&nbsp;</p>
<p><strong>二、引用计数算法：（老牌垃圾回收算法。无法处理循环引用，没有被Java采纳）</strong></p>
<p><strong>1、引用计数算法的概念：</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002443781597.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="e6217360-0985-46e8-88fd-022f1fc0fba5" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002451136455.png" alt="e6217360-0985-46e8-88fd-022f1fc0fba5" width="984" height="271" border="0"></a></p>
<p><strong>2、使用者举例：</strong></p>
<p>引用计数算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。很多地方应用到它。例如：</p>
<blockquote>
<p>微软公司的COM技术：Computer Object Model</p>
<p>使用ActionScript3的FlashPlayer</p>
<p>Python</p>

















</blockquote>
<p>但是，主流的java虚拟机并没有选用引用计数算法来管理内存，其中最主要的原因是：<span style="color: #0000ff;"><strong>它很难解决对象之间相互循环引用的问题</strong></span>。</p>
<p><strong>3、引用计数算法的问题：</strong></p>
<ul>
<li>引用和去引用伴随加法和减法，影响性能</li>
<li>致命的缺陷：<span style="color: #0000ff;">对于<strong>循环引用的对象</strong>无法进行回收</span></li>

















</ul>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002456281312.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="1a489e67-e047-408f-a97e-4a141e6ab3b0" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002460667613.png" alt="1a489e67-e047-408f-a97e-4a141e6ab3b0" width="968" height="253" border="0"></a></p>
<p>上面的3个图中，对于最右边的那张图而言：循环引用的计数器都不为0，但是他们对于根对象都已经不可达了，但是无法释放。</p>
<p><strong>循环引用的代码举例：</strong></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Object {
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span>     Object field = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 4</span>     
<span style="color: #008080;"> 5</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
</span><span style="color: #008080;"> 6</span>         Thread thread = <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
</span><span style="color: #008080;"> 7</span>             <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
</span><span style="color: #008080;"> 8</span>                 Object objectA = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Object();
</span><span style="color: #008080;"> 9</span>                 Object objectB = <span style="color: #0000ff;">new</span> Object();<span style="color: #008000;">//</span><span style="color: #008000;">位置1</span>
<strong><span style="color: #008080;">10</span>                 objectA.field =<span style="color: #000000;"> objectB;
</span><span style="color: #008080;">11</span>                 objectB.field = objectA;<span style="color: #008000;">//</span><span style="color: #008000;">位置2
</span></strong><span style="color: #008080;">12</span>                 <span style="color: #008000;">//</span><span style="color: #008000;">to do something</span>
<span style="color: #008080;">13</span>                 objectA = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
</span><span style="color: #008080;">14</span>                 objectB = <span style="color: #0000ff;">null</span>;<span style="color: #008000;">//</span><span style="color: #008000;">位置3</span>
<span style="color: #008080;">15</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">16</span> <span style="color: #000000;">        });
</span><span style="color: #008080;">17</span> <span style="color: #000000;">        thread.start();
</span><span style="color: #008080;">18</span>         <span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">);
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span>     
<span style="color: #008080;">21</span> }<span style="font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 1.5; background-color: #ffffff;">&nbsp;</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p><span style="line-height: 1.5;">上方代码看起来有点刻意为之，但其实在实际编程过程当中，是经常出现的，比如两个一对一关系的数据库对象，各自保持着对方的引用。最后一个无限循环只是为了保持JVM不退出，没什么实际意义。</span></p>
<p>代码解释：</p>
<p>代码中标注了1、2、3三个数字，当位置1的语句执行完以后，两个对象的引用计数全部为1。当位置2的语句执行完以后，两个对象的引用计数就全部变成了2。当位置3的语句执行完以后，也就是将二者全部归为空值以后，二者的引用计数仍然为1。根据引用计数算法的回收规则，引用计数没有归0的时候是不会被回收的。</p>
<p>对于我们现在使用的GC来说，当thread线程运行结束后，会将objectA和objectB全部作为待回收的对象。而<strong>如<span style="color: #0000ff;">果我们的GC采用上面所说的引用计数算法，则这两个对象永远不会被回收</span></strong>，即便我们在使用后显示的将对象归为空值也毫无作用。</p>
<p>&nbsp;</p>
<p><strong>三、根搜索算法：</strong></p>
<p><strong>1、根搜索算法的概念：</strong></p>
<p>　　由于引用计数算法的缺陷，所以JVM一般会采用一种新的算法，叫做<span style="color: #0000ff;"><strong>根搜索算法</strong></span>。它的处理方式就是，<strong><span style="color: #0000ff;">设</span><span style="color: #0000ff;">立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的</span></strong>。</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002468169242.jpg"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="7ab0f17b-13f7-4886-a24d-3813c2173891" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002477226386.jpg" alt="7ab0f17b-13f7-4886-a24d-3813c2173891" width="753" height="447" border="0"></a></p>
<p>如上图所示，ObjectD和ObjectE是互相关联的，但是由于GC roots到这两个对象不可达，所以最终D和E还是会被当做GC的对象，上图若是采用引用计数法，则A-E五个对象都不会被回收。</p>
<p>&nbsp;</p>
<p><strong>2、可达性分析：</strong></p>
<p>&nbsp;我们刚刚提到，设立若干种根对象，当<span style="color: #0000ff;">任何一个根对象到某一个对象均不可达时</span>，则认为这个对象是可以被回收的。我们在后面介绍标记-清理算法/标记整理算法时，也会一直强调<span style="color: #0000ff;">从根节点开始，对所有可达对象做一次标记，<span style="color: #000000;">那什么叫做可达呢？这里解释如下：</span></span></p>
<p><strong><span style="color: #0000ff;"><span style="color: #000000;">可达性分析：</span></span></strong></p>
<p><span style="color: #0000ff;"><span style="color: #000000;">　　从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为</span>“<span style="color: #000000;"><strong><span style="color: #0000ff;">引用链</span></strong>”，当一个对象到GC Roots没有任何引用链相连（用图论的概念来讲，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</span></span></p>
<p>&nbsp;</p>
<p><strong><span style="color: #0000ff;"><span style="color: #000000;">3、根（GC Roots）：</span></span></strong></p>
<p><span style="line-height: 1.5;">说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：</span></p>
<blockquote>
<p><strong>1、栈（栈帧中的本地变量表）中引用的对象。 </strong></p>
<p><strong>2、方法区中的静态成员。 </strong></p>
<p><strong>3、方法区中的常量引用的对象（全局变量）</strong></p>
<p><strong>4、本地方法栈中JNI（一般说的Native方法）引用的对象。</strong></p>
</blockquote>
<p>注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。</p>
<p>在根搜索算法的基础上，现代虚拟机的实现当中，<span style="color: #0000ff;"><strong>垃圾搜集的算法</strong></span>主要有三种，分别是<span style="color: #0000ff;"><strong>标记-清除算法、复制算法、标记-整理</strong></span>算法。这三种算法都扩充了根搜索算法，不过它们理解起来还是非常好理解的。</p>
<p>&nbsp;</p>
<p><strong>四、标记-清除算法：</strong></p>
<p><strong>1、标记清除算法的概念：</strong></p>
<p>标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，<span style="color: #0000ff;"><strong>首先通过根节点，标记所有从根节点开始的可达对象</strong></span>。因此，未被标记的对象就是未被引用的垃圾对象；然后，在清除阶段，清除所有未被标记的对象。</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002487061086.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="7de44970-2e02-46a1-a5d0-0663b21906c6" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002497066258.png" alt="7de44970-2e02-46a1-a5d0-0663b21906c6" width="944" height="414" border="0"></a></p>
<p><strong>2、标记-清除算法详解：</strong></p>
<p>它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>标记：标记的过程其实就是，<span style="color: #0000ff;">遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象</span>。</li>
<li>清除：清除的过程将遍历堆中所有的对象，<span style="color: #0000ff;">将没有标记的对象全部清除掉</span>。</li>
</ul>
<p>也就是说，<strong>就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行</strong>。</p>
<p>来看下面这张图：</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002507223903.jpg"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="47146934-c3a3-4976-991f-77e84ae008cc" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002514255816.jpg" alt="47146934-c3a3-4976-991f-77e84ae008cc" width="464" height="503" border="0"></a></p>
<p>上图代表的是程序运行期间所有对象的状态，<strong>它们的标志位全部是0</strong>（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿<strong>有效内存空间耗尽</strong>了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图：</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002520662647.jpg"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="5cbf57ce-c83a-40d2-b58a-b37d3eee3803" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002528002803.jpg" alt="5cbf57ce-c83a-40d2-b58a-b37d3eee3803" width="566" height="490" border="0"></a></p>
<p>上图中可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示：</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002539108475.jpg"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="8654ed59-fc00-446d-8995-a02ab57cf213" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002549412892.jpg" alt="8654ed59-fc00-446d-8995-a02ab57cf213" width="587" height="495" border="0"></a></p>
<p>上图可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可。</p>
<p><strong>疑问：为什么非要停止程序的运行呢？</strong></p>
<p>答：</p>
<p>这个其实也不难理解，假设我们的程序与GC线程是一起运行的，各位试想这样一种场景。</p>
<p>假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象。但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段。因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。</p>
<p>上面的结果当然令人无法接受，我们刚new了一个对象，结果经过一次GC，忽然变成null了，这还怎么玩？</p>
<p><strong>3、标记-清除算法的缺点：</strong></p>
<p>（1）首先，<strong>它的缺点就是<span style="color: #0000ff;">效率比较低</span>（递归与全堆对象遍历）</strong>，导致stop the world的时间比较长，尤其对于交互式的应用程序来说简直是无法接受。试想一下，如果你玩一个网站，这个网站一个小时就挂五分钟，你还玩吗？</p>
<p>（2）第二点主要的缺点，则是<strong>这种方式清理出来的<span style="color: #0000ff;">空闲内存是不连续的</span></strong>，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。</p>
<p>&nbsp;</p>
<p><strong>五、复制算法：（新生代的GC）</strong></p>
<p><strong>复制算法的概念：</strong></p>
<p>将原<span style="color: #0000ff;">有的内存空间分为两块，每次只使用其中一块</span>，在垃圾回收时，<span style="color: #0000ff;">将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收</span>。</p>
<ul>
<li>与标记-清除算法相比，复制算法是一种相对高效的回收方法</li>
<li>不适用于存活对象较多的场合，如老年代（复制算法<span style="color: #0000ff;"><strong>适合做新生代的GC</strong></span>）</li>
</ul>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002555814020.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="ff1e1846-e49c-4663-aee1-7c63628f567c" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002560357091.png" alt="ff1e1846-e49c-4663-aee1-7c63628f567c" width="871" height="421" border="0"></a></p>
<ul>
<li><span style="color: #0000ff;"><strong>复制算法的最大的问题是：空间的浪费</strong></span></li>
</ul>
<p>复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，这个太要命了。</p>
<p>所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是<span style="color: #0000ff;"><strong>将内存分为一块比较大的Eden空间和两块较小的Survivor空间</strong></span>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。<span style="color: #0000ff;">HotSpot虚拟机默认Eden和Survivor的大小比例是8:1</span>，也就是说，每次<span style="color: #0000ff;">新生代中可用内存空间</span>为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活<strong><span style="color: #0000ff;">，当Survivor空间不够用时，需要依赖于老年代进行分配<span style="color: #ff0000;">担保</span>，所以大对象直接进入老年代</span></strong>。整个过程如下图所示：</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002565501949.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="7e1f6ed2-e0c4-45e4-b7db-b59c28e1ee9c" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002573639064.png" alt="7e1f6ed2-e0c4-45e4-b7db-b59c28e1ee9c" width="833" height="394" border="0"></a></p>
<p>上图中，绿色箭头的位置代表的是大对象，大对象直接进入老年代。</p>
<p>根据上面的复制算法，现在我们来看下面的这个gc日志的数字，就应该能看得懂了吧：</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002579102165.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="6d59301f-f0c9-4fed-ba36-e66bc6574e8f" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201002585503293.png" alt="6d59301f-f0c9-4fed-ba36-e66bc6574e8f" width="942" height="414" border="0"></a></p>
<p>上方GC日志中，新生代的可用空间是13824K（eden区的12288K+from space的1536K）。而根据内存的地址计算得知，新生代的总空间为15M，而这个15M的空间是 = 13824K +to space 的 1536K。</p>
<p>&nbsp;</p>
<p><strong>六、标记-整理算法：（老年代的GC）</strong></p>
<p><strong>引入：</strong></p>
<p>&nbsp;&nbsp;&nbsp; 如果在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选中这种算法。</p>
<p><strong>概念：</strong></p>
<p>标记-压缩算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记；<span style="color: #0000ff;">但之后，它并不简单的清理未标记的对象，而是<strong>将所有的存活对象压缩到内存的一端；</strong></span><span style="color: #0000ff;">之后，清理边界外所有的空间</span>。</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201002594252194.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="cc79889a-0856-4018-92c3-c51108c9caea" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201003005357866.png" alt="cc79889a-0856-4018-92c3-c51108c9caea" width="963" height="389" border="0"></a></p>
<ul>
<li><strong>标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。<br></strong></li>
<li><strong>整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。</strong></li>


























</ul>
<p>上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
<p><strong><span style="color: #0000ff;">标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价</span>。</strong></p>
<ul>
<li>但是，标记/整理算法唯一的缺点就是效率也不高。</li>


























</ul>
<p>不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。</p>
<p><strong>标记-清除算法、复制算法、标记整理算法的总结：</strong></p>
<p>三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。因此，要想防止内存泄露，最根本的办法就是掌握好变量作用域，而不应该使用C/C++式内存管理方式。</p>
<p>在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。</p>
<p>它们的区别如下：（&gt;表示前者要优于后者，=表示两者效果一样）</p>
<p>（1）<span style="color: #0000ff;"><strong>效率</strong>：<strong>复制算法</strong></span>&gt;标记/整理算法&gt;标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。</p>
<p>（2）<span style="color: #0000ff;"><strong>内存整齐度</strong></span>：复制算法=标记/整理算法&gt;标记/清除算法。</p>
<p>（3）内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。</p>
<p>注1：可以看到标记/清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的。</p>
<p>注2：<strong><span style="color: #0000ff;">时间与空间不可兼得</span>。</strong></p>
<p>&nbsp;</p>
<p><strong>七、分代收集算法：（新生代的GC+老年代的GC）</strong></p>
<p>当前商业虚拟机的GC都是采用的“分代收集算法”，这并不是什么新的思想，只是<span style="color: #0000ff;"><strong>根据对象的存活周期的不同将内存划分为几块儿</strong></span>。一般是把Java堆分为新生代和老年代：<span style="color: #0000ff;"><strong>短命对象归为新生代，长命对象归为老年代</strong></span>。</p>
<ul>
<li><span style="color: #0000ff;"><strong>少量对象存活，适合复制算法</strong></span>：在<span style="color: #0000ff;"><strong>新生代</strong></span>中，每次GC时都发现<span style="color: #0000ff;">有大批对象死去，只有少量存活</span>，那就选用<span style="color: #0000ff;"><strong>复制算法</strong></span>，只需要付出少量存活对象的复制成本就可以完成GC。</li>
<li><span style="color: #0000ff;"><strong>大量对象存活，适合用标记-清理/标记-整理</strong></span>：在<span style="color: #0000ff;"><strong>老年代</strong></span>中，因为<span style="color: #0000ff;">对象存活率高</span>、没有额外空间对他进行分配担保，就必须使用“<strong>标记-清理</strong>”/“标记-整理”算法进行GC。</li>


























</ul>
<p>注：<strong>老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代</strong>。</p>
<p><strong>八、可触及性：</strong></p>
<p>所有的算法，需要能够识别一个垃圾对象，因此需要给出一个可触及性的定义。</p>
<p><strong style="line-height: 1.5;">可触及的：</strong></p>
<p>　　从根节点可以触及到这个对象。</p>
<p>&nbsp;&nbsp;&nbsp; 　　其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。</p>
<p><strong>可复活的：</strong></p>
<p>　　一旦所有引用被释放，就是可复活状态</p>
<p>　　因为在finalize()中可能复活该对象</p>
<p><strong>不可触及的：</strong></p>
<p>　　在finalize()后，可能会进入不可触及状态</p>
<p>　　不可触及的对象不可能复活</p>
<p>&nbsp;&nbsp;&nbsp; 　　要被回收。</p>
<p><strong>finalize方法复活对象的代码举例：</strong></p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> test03;
</span><span style="color: #008080;"> 2</span> 
<span style="color: #008080;"> 3</span> <span style="color: #008000;">/**</span>
<span style="color: #008080;"> 4</span> <span style="color: #008000;"> * Created by smyhvae on 2015/8/19.
</span><span style="color: #008080;"> 5</span>  <span style="color: #008000;">*/</span>
<span style="color: #008080;"> 6</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> CanReliveObj {
</span><span style="color: #008080;"> 7</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> CanReliveObj obj;
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span>     <span style="color: #008000;">//</span><span style="color: #008000;">当执行GC时，会执行finalize方法，并且只会执行一次</span>
<span style="color: #008080;">10</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> finalize() <span style="color: #0000ff;">throws</span><span style="color: #000000;"> Throwable {
</span><span style="color: #008080;">12</span>         <span style="color: #0000ff;">super</span><span style="color: #000000;">.finalize();
</span><span style="color: #008080;">13</span>         System.out.println("CanReliveObj finalize called"<span style="color: #000000;">);
</span><strong><span style="color: #008080;">14</span>         obj = <span style="color: #0000ff;">this</span>;   <span style="color: #008000;">//</span><span style="color: #008000;">当执行GC时，会执行finalize方法，然后这一行代码的作用是将null的object复活一下，然后变成了可触及性</span></strong>
<span style="color: #008080;">15</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">16</span> 
<span style="color: #008080;">17</span> <span style="color: #000000;">    @Override
</span><span style="color: #008080;">18</span>     <span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
</span><span style="color: #008080;">19</span>         <span style="color: #0000ff;">return</span> "I am CanReliveObj"<span style="color: #000000;">;
</span><span style="color: #008080;">20</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">21</span> 
<span style="color: #008080;">22</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> main(String[] args) <span style="color: #0000ff;">throws</span>
<span style="color: #008080;">23</span> <span style="color: #000000;">            InterruptedException {
</span><span style="color: #008080;">24</span>         obj = <span style="color: #0000ff;">new</span><span style="color: #000000;"> CanReliveObj();
</span><span style="color: #008080;">25</span>         obj = <span style="color: #0000ff;">null</span>;   <span style="color: #008000;">//</span><span style="color: #008000;">可复活</span>
<span style="color: #008080;">26</span>         System.out.println("第一次gc"<span style="color: #000000;">);
</span><span style="color: #008080;">27</span> <span style="color: #000000;">        System.gc();
</span><span style="color: #008080;">28</span>         Thread.sleep(1000<span style="color: #000000;">);
</span><span style="color: #008080;">29</span>         <span style="color: #0000ff;">if</span> (obj == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">30</span>             System.out.println("obj 是 null"<span style="color: #000000;">);
</span><span style="color: #008080;">31</span>         } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">32</span>             System.out.println("obj 可用"<span style="color: #000000;">);
</span><span style="color: #008080;">33</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">34</span>         obj = <span style="color: #0000ff;">null</span>;    <span style="color: #008000;">//</span><span style="color: #008000;">不可复活</span>
<span style="color: #008080;">35</span>         System.out.println("第二次gc"<span style="color: #000000;">);
</span><span style="color: #008080;">36</span> <span style="color: #000000;">        System.gc();
</span><span style="color: #008080;">37</span>         Thread.sleep(1000<span style="color: #000000;">);
</span><span style="color: #008080;">38</span>         <span style="color: #0000ff;">if</span> (obj == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
</span><span style="color: #008080;">39</span>             System.out.println("obj 是 null"<span style="color: #000000;">);
</span><span style="color: #008080;">40</span>         } <span style="color: #0000ff;">else</span><span style="color: #000000;"> {
</span><span style="color: #008080;">41</span>             System.out.println("obj 可用"<span style="color: #000000;">);
</span><span style="color: #008080;">42</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">43</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">44</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p><span style="line-height: 1.5;">我们需要注意第14行的注释。一开始，我们在第25行将obj设置为null，然后执行一次GC，本以为obj会被回收掉，其实并没有，因为GC的时候会调用11行的finalize方法，然后obj在第14行被复活了。紧接着又在第34行设置obj设置为null，然后执行一次GC，此时obj就被回收掉了，因为finalize方法只会执行一次。</span></p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201003018639839.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="31011217-d3a2-4e5b-9503-4f0b9bad9161" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201003029418268.png" alt="31011217-d3a2-4e5b-9503-4f0b9bad9161" width="378" height="199" border="0"></a></p>
<p><strong>finalize方法的使用总结：</strong></p>
<ul>
<li>经验：<span style="color: #0000ff;"><strong>避免使用finalize()</strong></span>，操作不慎可能导致错误。</li>
<li>优先级低，何时被调用，不确定</li>
</ul>
<p>何时发生GC不确定，自然也就不知道finalize方法什么时候执行</p>
<ul>
<li>如果要使用finalize去释放资源，我们可以使用try-catch-finally来替代它</li>
</ul>
<p><strong>&nbsp;</strong></p>
<p><strong>九、Stop-The-World：</strong></p>
<p><strong>1、Stop-The-World概念：</strong></p>
<p>　　Java中一种全局暂停的现象。</p>
<p><span style="color: #0000ff;"><strong>全局停顿，所有Java代码停止</strong></span>，native代码可以执行，但不能和JVM交互</p>
<p><span style="color: #0000ff;"><strong>多半情况下是由于GC引起</strong></span>。</p>
<p>&nbsp;&nbsp;&nbsp; 少数情况下由其他情况下引起，如：Dump线程、死锁检查、堆Dump。</p>
<p>&nbsp;</p>
<p><strong>2、GC时为什么会有全局停顿？</strong></p>
<p>&nbsp; &nbsp; （1）避免无法彻底清理干净</p>
<p>打个比方：类比在聚会，突然GC要过来打扫房间，聚会时很乱，<span style="color: #0000ff;">又有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动</span>了，才能将房间打扫干净。</p>
<p>&nbsp;&nbsp;&nbsp; 况且，如果没有全局停顿，会给GC线程造成很大的负担，GC算法的难度也会增加，GC很难去判断哪些是垃圾。</p>
<p>　&nbsp;（2）GC的工作必须在一个能确保<strong><span style="color: #0000ff;">一致性</span></strong>的快照中进行。</p>
<p>这里的一致性的意思是：在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现<strong><span style="color: #0000ff;">分析过程中对象引用关系还在不断变化</span></strong>的情况，该点不满足的话分析结果的准确性无法得到保证。</p>
<p>这点是导致GC进行时必须停顿所有Java执行线程的其中一个重要原因。</p>
<p><strong>3、Stop-The-World的</strong><strong>危害：</strong></p>
<blockquote>
<p><span style="color: #0000ff;"><strong>长时间服务停止，没有响应（将用户正常工作的线程全部暂停掉）</strong></span></p>
<p>遇到HA系统，可能引起主备切换，严重危害生产环境。</p>
<p>　　备注：HA：High Available, 高可用性集群。</p>
</blockquote>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201003035037139.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border: 0px;" title="d07bb3ea-1235-41d5-9fb1-56b4087d1acf" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201003040817483.png" alt="d07bb3ea-1235-41d5-9fb1-56b4087d1acf" width="391" height="143" border="0"></a></p>
<p>比如上面的这主机和备机：现在是主机在工作，此时如果主机正在GC造成长时间停顿，那么备机就会监测到主机没有工作，于是备机开始工作了；但是主机不工作只是暂时的，当GC结束之后，主机又开始工作了，那么这样的话，主机和备机就同时工作了。<span style="color: #0000ff;"><strong>主机和备机同时工作其实是非常危险</strong></span>的，很有可能会导致应用程序不一致、不能提供正常的服务等，进而影响生产环境。</p>
<p><strong>代码举例：</strong></p>
<p>（1）打印日志的代码：（每隔100ms打印一条）</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> PrintThread <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">long</span> starttime=<span style="color: #000000;">System.currentTimeMillis();
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">long</span> t=System.currentTimeMillis()-<span style="color: #000000;">starttime;
                System.out.println(</span>"time:"+<span style="color: #000000;">t);
                Thread.sleep(</span>100<span style="color: #000000;">);
            }
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(Exception e){

        }
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p><span style="line-height: 1.5;">上方代码中，是负责打印日志的代码，每隔100ms打印一条，并计算打印的时间。</span></p>
<p>（2）工作线程的代码：（工作线程，专门用来消耗内存）</p>
<div class="cnblogs_code"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">class</span> MyThread <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Thread{
    HashMap</span>&lt;Long,<span style="color: #0000ff;">byte</span>[]&gt; map=<span style="color: #0000ff;">new</span> HashMap&lt;Long,<span style="color: #0000ff;">byte</span>[]&gt;<span style="color: #000000;">();
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run(){
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;">{
            </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">true</span><span style="color: #000000;">){
                </span><span style="color: #0000ff;">if</span>(map.size()*512/1024/1024&gt;=450){   <span style="color: #008000;">//</span><span style="color: #008000;">如果map消耗的内存消耗大于450时，那就清理内存</span>
                    System.out.println("=====准备清理=====:"+<span style="color: #000000;">map.size());
                    map.clear();
                }

                </span><span style="color: #0000ff;">for</span>(<span style="color: #0000ff;">int</span> i=0;i&lt;1024;i++<span style="color: #000000;">){
                    map.put(System.nanoTime(), </span><span style="color: #0000ff;">new</span> <span style="color: #0000ff;">byte</span>[512<span style="color: #000000;">]);
                }
                Thread.sleep(</span>1<span style="color: #000000;">);
            }
        }</span><span style="color: #0000ff;">catch</span><span style="color: #000000;">(Exception e){
            e.printStackTrace();
        }
    }
}</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<p>&nbsp;</p>
<p><span style="line-height: 1.5;">然后，我们设置gc的参数为：</span></p>
<div class="cnblogs_code">
<pre>-Xmx512M -Xms512M -XX:+UseSerialGC -Xloggc:gc.log -XX:+PrintGCDetails -Xmn1m -XX:PretenureSizeThreshold=50 -XX:MaxTenuringThreshold=1</pre>
</div>
<p>&nbsp;</p>
<p>打印日志如下：</p>
<p><a href="http://images0.cnblogs.com/blog/641601/201508/201003048163342.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="8a8de388-7989-47f2-a7e1-496487e4be57" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/201003058941771.png" alt="8a8de388-7989-47f2-a7e1-496487e4be57" width="1035" height="459" border="0"></a></p>
<p>上图中，红色字体代表的正在GC。按道理来说，应该是每隔100ms会打印输出一条日志，但是当执行GC的时候，会出现全局停顿的情况，导致没有按时输出。</p>
<p>&nbsp;</p>
<p>下篇文章中，我们将对各种垃圾收集器进行介绍。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;"><strong>手有玫瑰，赠人余香。支付宝扫一扫吧：</strong></span></p>
<p><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/122006042073732.jpg" alt="" width="458" height="458"></p>
<p>&nbsp;</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="https://www.cnblogs.com/qianguyihao/category/587723.html" target="_blank">Java</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(4744233,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;64313984-87f0-e311-8d02-90b11c0b17d6&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/qianguyihao/" target="_blank"><img src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/20151116171645.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/qianguyihao/">千古壹号</a><br>
            <a href="http://home.cnblogs.com/u/qianguyihao/followees">关注 - 55</a><br>
            <a href="http://home.cnblogs.com/u/qianguyihao/followers">粉丝 - 1459</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;64313984-87f0-e311-8d02-90b11c0b17d6&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(4744233,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">7</span>
    </div>
    <div class="buryit" onclick="votePost(4744233,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/qianguyihao/p/4736162.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/qianguyihao/p/4736162.html" title="发布于2015-08-17 12:58">Java虚拟机详解03----常用JVM配置参数</a><br><a href="https://www.cnblogs.com/qianguyihao/p/4748313.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/qianguyihao/p/4748313.html" title="发布于2015-08-21 16:51">Java虚拟机详解05----垃圾收集器及GC参数</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2015-08-20 10:46</span> <a href="https://www.cnblogs.com/qianguyihao/">千古壹号</a> 阅读(<span id="post_view_count">10244</span>) 评论(<span id="post_comment_count">3</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4744233" rel="nofollow">编辑</a> <a href="https://www.cnblogs.com/smyhvae/p/4744233.html#" onclick="AddToWz(4744233);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=188761,cb_entryId=4744233,cb_blogApp=currentBlogApp,cb_blogUserGuid='64313984-87f0-e311-8d02-90b11c0b17d6',cb_entryCreatedDate='2015/8/20 10:46:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<br>
<div class="feedback_area_title">评论列表</div>
<div class="feedbackNoItems"></div>	

		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="https://www.cnblogs.com/smyhvae/p/4744233.html#3250813" class="layer">#1楼</a><a name="3250813" id="comment_anchor_3250813"></a>  <span class="comment_date">2015-08-20 11:37</span> <a id="a_comment_author_3250813" href="https://www.cnblogs.com/sqhua/" target="_blank">佩恩</a> <a href="http://msg.cnblogs.com/send/%E4%BD%A9%E6%81%A9" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3250813" class="blog_comment_body">写得真心好！<br><br>能不能介绍一下三色算法，我查了很多资料都看得不是很明白</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3250813,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3250813,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="https://www.cnblogs.com/smyhvae/p/4744233.html#3250834" class="layer">#2楼</a><a name="3250834" id="comment_anchor_3250834"></a>  <span class="comment_date">2015-08-20 12:55</span> <a id="a_comment_author_3250834" href="http://home.cnblogs.com/u/800639/" target="_blank">pingpongzh</a> <a href="http://msg.cnblogs.com/send/pingpongzh" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3250834" class="blog_comment_body">很清楚</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3250834,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3250834,&#39;Bury&#39;,this)">反对(0)</a></div>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="https://www.cnblogs.com/smyhvae/p/4744233.html#3251849" class="layer">#3楼</a><a name="3251849" id="comment_anchor_3251849"></a>[<span class="louzhu">楼主</span>]<span id="comment-maxId" style="display:none;">3251849</span><span id="comment-maxDate" style="display:none;">2015/8/21 16:40:13</span>  <span class="comment_date">2015-08-21 16:40</span> <a id="a_comment_author_3251849" href="https://www.cnblogs.com/qianguyihao/" target="_blank">千古壹号</a> <a href="http://msg.cnblogs.com/send/%E5%8D%83%E5%8F%A4%E5%A3%B9%E5%8F%B7" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3251849" class="blog_comment_body"><a href="https://www.cnblogs.com/smyhvae/p/4744233.html#3250834" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3250834);">@</a>
pingpongzh<br>谢谢~</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3251849,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3251849,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3251849_avatar" style="display:none;">http://pic.cnblogs.com/face/641601/20151116171645.png</span>
			</div>
		</div>
	<div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/smyhvae/p/4744233.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/smyhvae/p/4744233.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"><a href="http://www.ucancode.com/index.htm" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-工控&#39;)">【推荐】超50万VC++源码: 大型组态工控、电力仿真CAD与GIS源码库！</a><br><a href="https://gitee.com/enterprises?from=bky-2" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-gitee&#39;)">【推荐】专业便捷的企业级代码托管服务 - Gitee 码云</a><br></div>
<div id="opt_under_post"></div>
<script async="async" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/gpt.js.下载"></script>
<script>
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
</script>
<script>
  googletag.cmd.push(function() {
        googletag.defineSlot('/1090369/C1', [300, 250], 'div-gpt-ad-1546353474406-0').addService(googletag.pubads());
        googletag.defineSlot('/1090369/C2', [468, 60], 'div-gpt-ad-1539008685004-0').addService(googletag.pubads());
        googletag.pubads().enableSingleRequest();
        googletag.enableServices();
  });
</script>
<div id="cnblogs_c1" class="c_ad_block">
    <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;" data-google-query-id="CLG5-KTJsuACFRdsvQodzDMITw"><div id="google_ads_iframe_/1090369/C1_0__container__" style="border: 0pt none; display: inline-block; width: 300px; height: 250px;"><iframe frameborder="0" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/container.html" id="google_ads_iframe_/1090369/C1_0" title="3rd party ad content" name="" scrolling="no" marginwidth="0" marginheight="0" width="300" height="250" data-is-safeframe="true" sandbox="allow-forms allow-pointer-lock allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" data-google-container-id="1" style="border: 0px; vertical-align: bottom;" data-load-complete="true"></iframe></div></div>
</div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>相关博文：</b><br>·  <a href="https://www.cnblogs.com/vindia/p/7712300.html" target="_blank" onclick="clickRecomItmem(7712300,&#39;v6akP9H3HEpGRf5ROWOcrSl6eWbRjvFoW4551akNwy0EiS/gEjVu/a9ilnu5ZUrv1CAVoFOyNFHStTTwJ87R7Kl9Oea41tcj3NT9o1x+IT2vkgUlw+l2Ue7BSvtT2yf0KjNrMe8ttnxcWaKCsA==&#39;)">JVM虚拟机-GC</a><br>·  <a href="https://www.cnblogs.com/qdhxhz/p/9211095.html" target="_blank" onclick="clickRecomItmem(9211095,&#39;uDZ7jL6kL6c53E/uqYJQ7oAn/Ct07PDaigjBW4M2s2OgAWop9qgdr9tRhBOc+xaeNLjVoNDeSyfv1qRC6uMjRwopqKNpMo2aSs2liaWMkVtaF1uQINsDDlfIkhDaVaCsycfBYKqqrhDI2iWbfw==&#39;)">【JVM虚拟机】（2）---GC 算法与种类</a><br>·  <a href="https://www.cnblogs.com/boycelee/p/6886029.html" target="_blank" onclick="clickRecomItmem(6886029,&#39;KfSWBZ290SwQNTnEQTt+UVR+DeceCqv2nx6BQ9FlTGwtYDxWKt/YS7NU2DJ+Hs8gDO1nZ3cFCFmUrqWfnuxh5822o4CuHRYGUUvOki6whhObUU9yX7EvngG7td3pzUNPNa7V72qV6qQH0Vwx6g==&#39;)">Java虚拟机之GC</a><br>·  <a href="https://www.cnblogs.com/shijingjing07/p/6357768.html" target="_blank" onclick="clickRecomItmem(6357768,&#39;d1TV990pnE1997/cokE4qDES1tYDnqGqGnITWriO6EyQ9pZOXmzFY/L3od1blypoyDzVSSvUDV9786/XmRIgeiCMxiOiIxuGUbhGuKVYCAXON+v6iZGnslDdqAjHi7//DBuh3GZU/QAWoTLuGg==&#39;)">Java虚拟机详解</a><br>·  <a href="https://www.cnblogs.com/linkstar/p/9213720.html" target="_blank" onclick="clickRecomItmem(9213720,&#39;wH7DhhUXXUCBGsRKF5gZEqSG5xLXkAE9si8W87dl+dWJk0YNF8x1AthKRTqpxsVOXdY9p2sh1ISN1g97B6H0IyHpri0J6ZIIm1V+gmJQjiyEh7NoMpd1Xb8IAQtKXpm20NzzPP2UUNDG/rev1w==&#39;)">大战Java虚拟机【2】—— GC策略</a><br></div></div>
<div id="cnblogs_c2" class="c_ad_block">
    <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;" data-google-query-id="CNe6-KTJsuACFRrRlgodkJIBUw"><div id="google_ads_iframe_/1090369/C2_0__container__" style="border: 0pt none;"><iframe id="google_ads_iframe_/1090369/C2_0" title="3rd party ad content" name="google_ads_iframe_/1090369/C2_0" width="468" height="60" scrolling="no" marginwidth="0" marginheight="0" frameborder="0" style="border: 0px; vertical-align: bottom;" data-google-container-id="2" data-load-complete="true" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/saved_resource.html"></iframe></div></div>
</div>
<div id="under_post_kb"><div class="itnews c_ad_block"><b>最新新闻</b>：<br> ·  <a href="https://news.cnblogs.com/n/619083/" target="_blank">QQ20岁：20年版本迭代只做一件事情</a><br> ·  <a href="https://news.cnblogs.com/n/619081/" target="_blank">前Google特斯拉Uber三巨头打造无人驾驶“极光之队”</a><br> ·  <a href="https://news.cnblogs.com/n/619080/" target="_blank">李彦宏：创业18年，始终保持警惕</a><br> ·  <a href="https://news.cnblogs.com/n/619079/" target="_blank">苹果降价短期销量增八成 被指饮鸩止渴伤害品牌</a><br> ·  <a href="https://news.cnblogs.com/n/619078/" target="_blank">被冒充洽谈5G基建业务 中国铁塔连发三声明斥“李鬼”</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
 if(enablePostBottom()) {
    codeHighlight();
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverT2();
    deliverC1();
    deliverC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);  
}
</script>
</div>

    
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/qianguyihao/">千古壹号</a><br>园龄：<a href="https://home.cnblogs.com/u/qianguyihao/" title="入园时间：2014-06-10">4年8个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/qianguyihao/followers/">1459</a><br>关注：<a href="https://home.cnblogs.com/u/qianguyihao/followees/">55</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;64313984-87f0-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('64313984-87f0-e311-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/01/01&#39;);return false;">&lt;</a></td><td align="center">2019年2月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2019/03/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td class="CalOtherMonthDay" align="center">31</td><td align="center">1</td><td class="CalWeekendDay" align="center">2</td></tr><tr><td class="CalWeekendDay" align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td class="CalWeekendDay" align="center">9</td></tr><tr><td class="CalWeekendDay" align="center">10</td><td class="CalTodayDay" align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td align="center">15</td><td class="CalWeekendDay" align="center">16</td></tr><tr><td class="CalWeekendDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td align="center">20</td><td align="center">21</td><td align="center">22</td><td class="CalWeekendDay" align="center">23</td></tr><tr><td class="CalWeekendDay" align="center">24</td><td align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td></tr><tr><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td><td class="CalOtherMonthDay" align="center">7</td><td class="CalOtherMonthDay" align="center">8</td><td class="CalOtherMonthDay" align="center">9</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block"></div><div id="sidebar_categories">
<div id="sidebar_postcategory" class="catListPostCategory sidebar-block">
<h3 class="catListTitle">随笔分类<span style="font-size:11px;font-weight:normal">(158)</span></h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="https://www.cnblogs.com/qianguyihao/category/587732.html">Android开发(54)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="https://www.cnblogs.com/qianguyihao/category/638310.html">C/C++编程(2)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="https://www.cnblogs.com/qianguyihao/category/587723.html">Java(15)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="https://www.cnblogs.com/qianguyihao/category/634173.html">JavaWeb(10)</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="https://www.cnblogs.com/qianguyihao/category/604950.html">Linux(5)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="https://www.cnblogs.com/qianguyihao/category/740114.html">前端(42)</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="https://www.cnblogs.com/qianguyihao/category/774934.html">设计(2)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="https://www.cnblogs.com/qianguyihao/category/722932.html">数据结构(9)</a> </li>

<li><a id="CatList_LinkList_0_Link_8" href="https://www.cnblogs.com/qianguyihao/category/636369.html">数据库(11)</a> </li>

<li><a id="CatList_LinkList_0_Link_9" href="https://www.cnblogs.com/qianguyihao/category/825301.html">心智(8)</a> </li>

</ul>

</div>

<div id="sidebar_postarchive" class="catListPostArchive sidebar-block">
<h3 class="catListTitle">随笔档案<span style="font-size:11px;font-weight:normal">(156)</span></h3>

<ul>

<li><a id="CatList_LinkList_1_Link_0" href="https://www.cnblogs.com/qianguyihao/archive/2018/12.html">2018年12月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_1" href="https://www.cnblogs.com/qianguyihao/archive/2018/09.html">2018年9月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_2" href="https://www.cnblogs.com/qianguyihao/archive/2018/07.html">2018年7月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_3" href="https://www.cnblogs.com/qianguyihao/archive/2018/06.html">2018年6月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_4" href="https://www.cnblogs.com/qianguyihao/archive/2018/04.html">2018年4月 (3)</a> </li>

<li><a id="CatList_LinkList_1_Link_5" href="https://www.cnblogs.com/qianguyihao/archive/2018/03.html">2018年3月 (7)</a> </li>

<li><a id="CatList_LinkList_1_Link_6" href="https://www.cnblogs.com/qianguyihao/archive/2018/02.html">2018年2月 (12)</a> </li>

<li><a id="CatList_LinkList_1_Link_7" href="https://www.cnblogs.com/qianguyihao/archive/2018/01.html">2018年1月 (9)</a> </li>

<li><a id="CatList_LinkList_1_Link_8" href="https://www.cnblogs.com/qianguyihao/archive/2017/08.html">2017年8月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_9" href="https://www.cnblogs.com/qianguyihao/archive/2017/07.html">2017年7月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_10" href="https://www.cnblogs.com/qianguyihao/archive/2016/09.html">2016年9月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_11" href="https://www.cnblogs.com/qianguyihao/archive/2016/08.html">2016年8月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_12" href="https://www.cnblogs.com/qianguyihao/archive/2016/05.html">2016年5月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_13" href="https://www.cnblogs.com/qianguyihao/archive/2016/04.html">2016年4月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_14" href="https://www.cnblogs.com/qianguyihao/archive/2016/03.html">2016年3月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_15" href="https://www.cnblogs.com/qianguyihao/archive/2016/02.html">2016年2月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_16" href="https://www.cnblogs.com/qianguyihao/archive/2016/01.html">2016年1月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_17" href="https://www.cnblogs.com/qianguyihao/archive/2015/11.html">2015年11月 (3)</a> </li>

<li><a id="CatList_LinkList_1_Link_18" href="https://www.cnblogs.com/qianguyihao/archive/2015/10.html">2015年10月 (4)</a> </li>

<li><a id="CatList_LinkList_1_Link_19" href="https://www.cnblogs.com/qianguyihao/archive/2015/09.html">2015年9月 (8)</a> </li>

<li><a id="CatList_LinkList_1_Link_20" href="https://www.cnblogs.com/qianguyihao/archive/2015/08.html">2015年8月 (9)</a> </li>

<li><a id="CatList_LinkList_1_Link_21" href="https://www.cnblogs.com/qianguyihao/archive/2015/07.html">2015年7月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_22" href="https://www.cnblogs.com/qianguyihao/archive/2015/06.html">2015年6月 (1)</a> </li>

<li><a id="CatList_LinkList_1_Link_23" href="https://www.cnblogs.com/qianguyihao/archive/2015/05.html">2015年5月 (3)</a> </li>

<li><a id="CatList_LinkList_1_Link_24" href="https://www.cnblogs.com/qianguyihao/archive/2015/04.html">2015年4月 (4)</a> </li>

<li><a id="CatList_LinkList_1_Link_25" href="https://www.cnblogs.com/qianguyihao/archive/2015/03.html">2015年3月 (2)</a> </li>

<li><a id="CatList_LinkList_1_Link_26" href="https://www.cnblogs.com/qianguyihao/archive/2014/12.html">2014年12月 (7)</a> </li>

<li><a id="CatList_LinkList_1_Link_27" href="https://www.cnblogs.com/qianguyihao/archive/2014/11.html">2014年11月 (7)</a> </li>

<li><a id="CatList_LinkList_1_Link_28" href="https://www.cnblogs.com/qianguyihao/archive/2014/10.html">2014年10月 (26)</a> </li>

<li><a id="CatList_LinkList_1_Link_29" href="https://www.cnblogs.com/qianguyihao/archive/2014/09.html">2014年9月 (8)</a> </li>

<li><a id="CatList_LinkList_1_Link_30" href="https://www.cnblogs.com/qianguyihao/archive/2014/08.html">2014年8月 (11)</a> </li>

<li><a id="CatList_LinkList_1_Link_31" href="https://www.cnblogs.com/qianguyihao/archive/2014/07.html">2014年7月 (12)</a> </li>

<li><a id="CatList_LinkList_1_Link_32" href="https://www.cnblogs.com/qianguyihao/archive/2014/06.html">2014年6月 (2)</a> </li>

</ul>

</div>

</div><div id="sidebar_scorerank" class="sidebar-block">
<div class="catListBlogRank">
<h3 class="catListTitle">积分与排名</h3>
<ul>
	<li class="liScore">
		积分 -	377883
	</li>
	<li class="liRank">
		排名 -	532
	</li>
</ul>
</div>


</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/qianguyihao/p/8732781.html#4175905">1. Re:裸辞两个月，海投一个月，从Android转战Web前端的求职之路</a></li>
        <li class="recent_comment_body">@名侦探柯东可以加一些技术交流群，里面的大佬应该不少。和他们多聊聊，熟悉起来，肯定能帮你内推。你平时多关注网上的信息和资源，总能发现一些交流群的。...</li>
        <li class="recent_comment_author">--千古壹号</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/qianguyihao/p/8732781.html#4174396">2. Re:裸辞两个月，海投一个月，从Android转战Web前端的求职之路</a></li>
        <li class="recent_comment_body">大公司没有同学，朋友的话，怎么内推呢？</li>
        <li class="recent_comment_author">--名侦探柯东</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/qianguyihao/p/4965163.html#4169311">3. Re:阿里云+wordpress搭建个人博客网站【小白专用的图文教程】</a></li>
        <li class="recent_comment_body"><a href="https://www.cnblogs.com/smyhvae/p/4744233.html" target="_blank"></a><br>这也是我刚搭的博客，正在备案，有兴趣的可以来光顾一下哟；记录一些杂七杂八的日记，请多指教</li>
        <li class="recent_comment_author">--我的世界只因有你</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/qianguyihao/p/4042303.html#4162123">4. Re:MySQL数据库学习笔记（六）----MySQL多表查询之外键、表连接、子查询、索引</a></li>
        <li class="recent_comment_body">查询月薪比平均月薪高的员工的名字select avg(salary),namefrom employeegoup by dept_idhaving avg(salary)&lt;salary 不知道是不是这......</li>
        <li class="recent_comment_author">--DMQ小七</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/qianguyihao/p/7256371.html#4161261">5. Re:CSS盒模型详解（图文教程）</a></li>
        <li class="recent_comment_body">不错，讲的非常清晰</li>
        <li class="recent_comment_author">--k5Asher</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/qianguyihao/p/3788534.html">1. Java配置----JDK开发环境搭建及环境变量配置(618058)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4390905.html">2. 第一次使用Android Studio时你应该知道的一切配置(366854)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4456420.html">3. 第一次使用Android Studio时你应该知道的一切配置（三）：gradle项目构建(118646)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4965163.html">4. 阿里云+wordpress搭建个人博客网站【小白专用的图文教程】(88810)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4392611.html">5. 第一次使用Android Studio时你应该知道的一切配置（二）：新建一个属于自己的工程并安装Genymotion模拟器(76565)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4004983.html">6. Android系列之网络（一）----使用HttpClient发送HTTP请求（通过get方法获取数据）(63092)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4133292.html">7. Android系列之UI组件----Menu菜单(51450)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4585340.html">8. 在Android Studio中使用shareSDK进行社会化分享（图文教程）(51214)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4022844.html">9. 使用Android Studio搭建Android集成开发环境（图文教程）(36959)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4140877.html">10. JavaWeb学习之Servlet（四）----ServletConfig获取配置信息、ServletContext的应用(32265)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/qianguyihao/p/8732781.html">1. 裸辞两个月，海投一个月，从Android转战Web前端的求职之路(78)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4585340.html">2. 在Android Studio中使用shareSDK进行社会化分享（图文教程）(35)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4390905.html">3. 第一次使用Android Studio时你应该知道的一切配置(34)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4965163.html">4. 阿里云+wordpress搭建个人博客网站【小白专用的图文教程】(28)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/3788534.html">5. Java配置----JDK开发环境搭建及环境变量配置(21)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4046862.html">6. JavaWeb学习----JSP简介及入门（含Eclipse for Java EE及Tomcat的配置）(18)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4850684.html">7. HTML标签----图文详解(17)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4456420.html">8. 第一次使用Android Studio时你应该知道的一切配置（三）：gradle项目构建(15)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4855106.html">9. CSS样式----CSS属性：字体属性和文本属性（图文详解）(14)</a></li><li><a href="https://www.cnblogs.com/qianguyihao/p/4392611.html">10. 第一次使用Android Studio时你应该知道的一切配置（二）：新建一个属于自己的工程并安装Genymotion模拟器(13)</a></li></ul></div>
</div>
</div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2019 千古壹号
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->



<iframe id="google_osd_static_frame_957051025901" name="google_osd_static_frame" style="display: none; width: 0px; height: 0px;" src="./Java虚拟机详解04----GC算法和种类【重要】 - 千古壹号 - 博客园_files/saved_resource(1).html"></iframe></body></html>